{
    "id": "memory_plugin",
    "code": "// Configuration\nconst CONFIG = {\n  API_VERSION: \"v2\",\n  CLIENT: \"typingmind\",\n  CLIENT_VERSION: \"4\",\n  CACHE_DURATION_MS: 60000, // 1 minute default\n  DEFAULT_API_URL: \"DEFAULT_API_URL\" // Fallback if not in settings\n};\n\n// Simple memory cache\nconst memoryCache = {\n  data: {},\n  \n  set(key, value, ttl = CONFIG.CACHE_DURATION_MS) {\n    this.data[key] = {\n      value,\n      expiry: Date.now() + ttl\n    };\n  },\n  \n  get(key) {\n    const item = this.data[key];\n    if (!item) return null;\n    \n    if (Date.now() > item.expiry) {\n      delete this.data[key];\n      return null;\n    }\n    \n    return item.value;\n  },\n  \n  invalidate(key) {\n    delete this.data[key];\n  },\n  \n  invalidateAll() {\n    this.data = {};\n  }\n};\n\n// Debug logging helper\nfunction log(message, data, userSettings) {\n  // Always log to console for developer debugging\n  console.log(`[Memory Box] ${message}`, data);\n  \n  // Only return debug info to the user if debug mode is enabled\n  if (userSettings && userSettings.debug === 'on') {\n    return `DEBUG: ${message} ${JSON.stringify(data, null, 2)}`;\n  }\n  \n  return null;\n}\n\n// Helper function to get the memory endpoint URL\nfunction getMemoryEndpoint(userSettings) {\n  // Use API URL from settings or fall back to default\n  const apiBase = userSettings.apiUrl || CONFIG.DEFAULT_API_URL;\n  \n  // Ensure the URL ends with a slash\n  const baseUrl = apiBase.endsWith('/') ? apiBase : apiBase + '/';\n  \n  // Construct the full endpoint URL\n  return `${baseUrl}${CONFIG.API_VERSION}/memory?client=${CONFIG.CLIENT}&version=${CONFIG.CLIENT_VERSION}`;\n}\n\n// API request helper\nasync function apiRequest(path, options, userSettings) {\n  const debugInfo = [];\n  const requestDebug = log('API Request:', { url: path, method: options.method }, userSettings);\n  if (requestDebug) debugInfo.push(requestDebug);\n  \n  try {\n    // Check if caching is enabled\n    const isCacheEnabled = userSettings.cacheEnabled !== 'off';\n    \n    // For GET requests, check cache first\n    if (isCacheEnabled && options.method === 'GET') {\n      const cacheKey = `${path}_${JSON.stringify(options.headers)}`;\n      const cachedData = memoryCache.get(cacheKey);\n      \n      if (cachedData) {\n        const cacheDebug = log('Using cached data:', { path }, userSettings);\n        if (cacheDebug) debugInfo.push(cacheDebug);\n        \n        return {\n          ...cachedData,\n          _debug: debugInfo.length > 0 ? debugInfo : undefined\n        };\n      }\n    }\n    \n    // Set up abort controller for timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n    \n    // Make the request\n    const response = await fetch(path, {\n      ...options,\n      signal: controller.signal\n    });\n    \n    // Clear the timeout\n    clearTimeout(timeoutId);\n    \n    // Handle errors\n    if (!response.ok) {\n      const errorText = await response.text();\n      const errorDebug = log('API Error:', { status: response.status, error: errorText }, userSettings);\n      if (errorDebug) debugInfo.push(errorDebug);\n      \n      throw new Error(`API error (${response.status}): ${errorText}`);\n    }\n    \n    // Parse the response\n    const data = await response.json();\n    const responseDebug = log('API Response:', { status: response.status, dataSize: JSON.stringify(data).length }, userSettings);\n    if (responseDebug) debugInfo.push(responseDebug);\n    \n    // Cache the result for GET requests\n    if (isCacheEnabled && options.method === 'GET') {\n      const cacheKey = `${path}_${JSON.stringify(options.headers)}`;\n      memoryCache.set(cacheKey, data);\n    }\n    \n    // Add debug info if available\n    if (debugInfo.length > 0) {\n      return {\n        ...data,\n        _debug: debugInfo\n      };\n    }\n    \n    return data;\n  } catch (error) {\n    // Handle timeout errors\n    if (error.name === 'AbortError') {\n      const timeoutDebug = log('API Timeout:', { timeout: 10000 }, userSettings);\n      if (timeoutDebug) debugInfo.push(timeoutDebug);\n      \n      throw new Error('Request timed out. The Memory Box server took too long to respond.');\n    }\n    \n    // Log other errors\n    const errorDebug = log('API Error:', { message: error.message }, userSettings);\n    if (errorDebug) debugInfo.push(errorDebug);\n    \n    // Re-throw with debug info\n    const enhancedError = new Error(error.message);\n    enhancedError._debug = debugInfo;\n    throw enhancedError;\n  }\n}\n\n// Format memory with date if needed\nfunction formatMemory(memory, bucketId, userSettings) {\n  log('Formatting memory:', { length: memory.length, bucketId }, userSettings);\n  \n  // Check if memory already has a date prefix\n  if (!memory.match(/^\\d{4}-\\d{2}-\\d{2}/)) {\n    const today = new Date();\n    const formattedDate = today.toISOString().split(\"T\")[0];\n    memory = `${formattedDate}\\n\\n${memory}`;\n    log('Added date prefix:', { date: formattedDate }, userSettings);\n  }\n  \n  return memory;\n}\n\nasync function queryMemories(text, userSettings) {\n  log('Searching memories:', { query: text }, userSettings);\n  \n  try {\n    const endpoint = getMemoryEndpoint(userSettings);\n    const url = new URL(endpoint);\n    url.searchParams.append('query', text);\n    url.searchParams.append('v', 2);\n    \n    const memories = await apiRequest(url.toString(), {\n      method: \"GET\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `Bearer ${userSettings.token}`\n      }\n    }, userSettings);\n    \n    log('Search results:', { count: memories.length }, userSettings);\n    \n    return memories;\n  } catch (error) {\n    log('Search error:', { message: error.message }, userSettings);\n    \n    return [];\n  }\n}\n\nasync function fetchAllMemories(userSettings) {\n  log('Fetching all memories', {}, userSettings);\n  \n  try {\n    const endpoint = getMemoryEndpoint(userSettings);\n    const url = new URL(endpoint);\n    url.searchParams.append('all', 'true');\n    url.searchParams.append('v', 2);\n    \n    const memories = await apiRequest(url.toString(), {\n      method: \"GET\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `Bearer ${userSettings.token}`\n      }\n    }, userSettings);\n    \n    log('Fetched all memories:', { count: memories.length }, userSettings);\n    \n    return memories;\n  } catch (error) {\n    log('Error fetching all memories:', { message: error.message }, userSettings);\n    \n    return [];\n  }\n}\n\nasync function fetchMemoriesFromBucket(userSettings, bucketId) {\n  // Use provided bucketId or fall back to settings\n  const bucketToUse = bucketId || userSettings.bucket;\n  \n  // If no bucket is available, return an error\n  if (!bucketToUse) {\n    log('No bucket specified', {}, userSettings);\n    \n    return [];\n  }\n  \n  log('Fetching memories from bucket:', { bucket: bucketToUse }, userSettings);\n  \n  try {\n    const endpoint = getMemoryEndpoint(userSettings);\n    const url = new URL(endpoint);\n    url.searchParams.append('bucketId', bucketToUse);\n    \n    const memories = await apiRequest(url.toString(), {\n      method: \"GET\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `Bearer ${userSettings.token}`\n      }\n    }, userSettings);\n    \n    log('Fetched bucket memories:', { bucket: bucketToUse, count: memories.length }, userSettings);\n    \n    return memories;\n  } catch (error) {\n    log('Error fetching bucket memories:', { bucket: bucketToUse, message: error.message }, userSettings);\n    \n    return [];\n  }\n}\n\nasync function addMemory(memory, bucketId, userSettings) {\n  // Use provided bucketId or fall back to settings\n  const bucketToUse = bucketId || userSettings.bucket;\n  \n  // Format the memory with date if needed\n  const formattedMemory = formatMemory(memory, bucketToUse, userSettings);\n  \n  log('Adding memory:', { length: formattedMemory.length, bucket: bucketToUse }, userSettings);\n  \n  try {\n    const endpoint = getMemoryEndpoint(userSettings);\n    \n    const newMemo = { text: formattedMemory };\n    if (bucketToUse) {\n      newMemo.bucketId = bucketToUse;\n    }\n    \n    const result = await apiRequest(endpoint, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": `Bearer ${userSettings.token}`\n      },\n      body: JSON.stringify(newMemo)\n    }, userSettings);\n    \n    log('Memory added successfully:', { id: result.id }, userSettings);\n    \n    // Invalidate relevant caches\n    if (userSettings.cacheEnabled !== 'off') {\n      const cacheKey1 = `${endpoint}_all=true`;\n      const cacheKey2 = bucketToUse ? `${endpoint}_bucketId=${bucketToUse}` : null;\n      \n      memoryCache.invalidate(cacheKey1);\n      if (cacheKey2) memoryCache.invalidate(cacheKey2);\n      \n      log('Cache invalidated for:', { keys: [cacheKey1, cacheKey2].filter(Boolean) }, userSettings);\n    }\n    \n    return `Memory stored: ${memory}`;\n  } catch (error) {\n    log('Error adding memory:', { message: error.message }, userSettings);\n    \n    return `Error storing memory: ${error.message}`;\n  }\n}\n\nasync function memory_plugin(params, userSettings) {\n  // Start with debug info if enabled\n  let debugInfo = [];\n  const initialDebug = log('Memory Box plugin called:', { params }, userSettings);\n  if (initialDebug) debugInfo.push(initialDebug);\n  \n  // Validate token\n  if (!userSettings.token) {\n    log('Missing token in userSettings', {}, userSettings);\n    return \"ALERT: Please go to the Memory Box settings and set your token to be able to store and retrieve memories. You can get your token from the Memory Box website at https://www.memoryplugin.com. NOTE_FOR_AI: Show this message to the user in your reply.\";\n  }\n\n  // Validate required parameters based on mode\n  if (!params.mode) {\n    log('Missing mode parameter', {}, userSettings);\n    return \"Error: mode is required and can be 'search', 'store', 'load_all', or 'load_bucket'.\";\n  }\n\n  // Use the bucket from params if provided, otherwise use the default from settings\n  const bucketToUse = params.bucket || userSettings.bucket;\n  \n  // Check for special \\m suffix in memory text\n  if (params.mode === \"store\" && params.memory && params.memory.endsWith('\\\\m')) {\n    params.memory = params.memory.slice(0, -2).trim();\n    log('Removed \\\\m suffix from memory', {}, userSettings);\n  }\n\n  try {\n    switch (params.mode) {\n      case \"search\":\n        if (!params.query) {\n          log('Missing query parameter for search mode', {}, userSettings);\n          return \"Error: 'query' parameter is required when mode is 'search'.\";\n        }\n        const searchResults = await queryMemories(params.query, userSettings);\n        return searchResults.map(m => m.text);\n        \n      case \"store\":\n        if (!params.memory) {\n          log('Missing memory parameter for store mode', {}, userSettings);\n          return \"Error: 'memory' parameter is required when mode is 'store'.\";\n        }\n        return await addMemory(params.memory, bucketToUse, userSettings);\n        \n      case \"load_all\":\n        if (bucketToUse) {\n          return await fetchMemoriesFromBucket(userSettings, bucketToUse);\n        }\n        return await fetchAllMemories(userSettings);\n        \n      case \"load_bucket\":\n        return await fetchMemoriesFromBucket(userSettings, bucketToUse);\n        \n      default:\n        log('Invalid mode', { mode: params.mode }, userSettings);\n        return `Error: Invalid mode '${params.mode}'. Mode must be 'search', 'store', 'load_all', or 'load_bucket'.`;\n    }\n  } catch (error) {\n    log('Unhandled error in memory_plugin:', { message: error.message }, userSettings);\n    \n    return `Error: ${error.message}`;\n  }\n}",
    "uuid": "ab2107bc-1884-4fa9-98f4-2721664e6878",
    "emoji": "🧠",
    "title": "Memory Box",
    "iconURL": "https://www.memoryplugin.com/icon-white-bg.png",
    "syncedAt": "2025-02-27T12:50:00.000Z",
    "deletedAt": null,
    "openaiSpec": {
        "name": "memory_plugin",
        "parameters": {
            "type": "object",
            "required": [
                "mode"
            ],
            "properties": {
                "mode": {
                    "enum": [
                        "store",
                        "search",
                        "load_all",
                        "load_bucket"
                    ],
                    "type": "string",
                    "description": "Required. Mode of operation:\n- 'store': Add memories proactively when you detect important information or when the user uses '\\m'.\n- 'search': Use to find specific memories. This is the default mode for looking up information.\n- 'load_all': ONLY use when explicitly requested by user. Never use this mode automatically.\n- 'load_bucket': **Use this mode to load memories from a specific bucket.**"
                },
                "query": {
                    "type": "string",
                    "description": "Search term to find specific memories. Required in 'search' mode. Only use search mode when you need to check for specific information and haven't loaded memories yet in this conversation."
                },
                "bucket": {
                    "type": "string",
                    "description": "Bucket name to store or load memories. Optional in all modes. When provided, it overrides the default bucket set in user settings. If not provided, the default bucket from settings will be used."
                },
                "memory": {
                    "type": "string",
                    "description": "Text to remember. Required in 'store' mode. Be succinct and focus on important details. Follow the formatting guidelines in the system prompt."
                }
            }
        },
        "description": "Memory Box stores and recalls user information for personalized interactions. Be proactive in storing relevant details without waiting for user prompts. If a message ends with '\\m', treat it as a request to remember the preceding information. Always check loaded memories for relevant details before asking the user. Store information succinctly.\n\n**Important:** The plugin uses the bucket specified in user settings by default. When the user explicitly mentions a different bucket in a message, use that bucket instead by providing it in the 'bucket' parameter.\n\nUse 'search' mode only when you need to look up specific information and haven't loaded memories yet in this conversation. Once you've loaded memories using either 'load_all' or 'load_bucket', just check those directly instead of using search.\n\nIf unsure about storing information, ask the user if they want it remembered. Use appropriate modes and parameters to store or fetch memories. Display any returned alerts or error messages to the user."
    },
    "userSettings": [
        {
            "name": "token",
            "type": "password",
            "label": "User Auth Token",
            "description": "Your auth token, visible on the Memory Box dashboard after logging in. Required.",
            "required": true
        },
        {
            "name": "apiUrl",
            "type": "text",
            "label": "API URL",
            "description": "The Memory Box API URL. Only change this if instructed to do so.",
            "defaultValue": "https://e0fb-47-39-133-151.ngrok-free.app/api/"
        },
        {
            "name": "bucket",
            "type": "text",
            "label": "Default Bucket",
            "description": "Your default memory bucket name."
        },
        {
            "name": "debug",
            "type": "enum",
            "label": "Debug Mode",
            "description": "Enable debug mode for troubleshooting. Only turn this on when diagnosing issues.",
            "values": ["off", "on"],
            "defaultValue": "off"
        },
        {
            "name": "cacheEnabled",
            "type": "enum",
            "label": "Enable Caching",
            "description": "Cache API responses to improve performance. Disable if you need real-time updates.",
            "values": ["on", "off"],
            "defaultValue": "on"
        }
    ]
}
